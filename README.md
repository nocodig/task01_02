<!-- 简答题答案以及说明 -->

# 简答

## 一、说出下列最终执行结果，并解释为什么？
```
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function() {
    console.log(i);
  }
}

a[6]()
```

答：程序输出结果为10；由于var关键字不会产生块作用域，在全局范围内有效，此时数组a中的生成的方法访问的都是全局变量i，当进行调用时，此时变量i的已经变成了10.所以最后输出的结果也是10.

解决办法：
- 将关键字var 换成let，保证每次循环的代码块i值独立。
- 或者使用闭包的方式，将i的值传入后，保留i的值，不受全局变量i影响

## 二、请说出下列最终的执行结果，并解释为什么
```
var tmp = 123;

if (true) {
  console.log(tmp);
  let tmp;
}
```
答：最终会执行报错。由于if中的tmp绑定的是let声明的tmp，且let具有如下特性：
- 存在块级作用域，在 if 中，此时生效的变量是let声明的tmp
- 不存在变量提升，且在声明前不能使用，存在暂时性死区
- 不能重复声明

## 三、结合es6新语法，用最简单的方式找出数组中最小的值
```
var arr = [12,34,32,89,4]
```

答：
```
Math.min(...arr)
```

## 四、详细说明var、let、const三种声明方式间的差别

答：
- var
  - 存在声明提升，且使用undefind进行初始化，可以在声明前使用
  - 仅存在全局作用域和函数作用域，不存在块作用域
  - 可以进行多次赋值
  - 可以重复定义
  - 声明时不必给初始值
- let
  - 存在块级作用域
  - 存在声明提升，但是未进行初始化，不能在声明前使用
  - 可以多次赋值
  - 不能重复定义
  - 声明时不必给初始值
- const
  - 存在块级作用域
  - 存在声明提升，但是未进行初始化，不能在声明前使用
  - 声明时必须有初始值
  - 不能多次赋值
  - 不能重复定义

## 五、请说出下列代码的最终输出结果，并解释为什么

```
var a = 10;
var obj = {
  a:20,
  fn() {
    setTimeout(() => {
      console.log(this.a)
    })
  }
}

obj.fn()
```

答:输入20；fn函数内部的this是obj，箭头函数会默认帮我们绑定外层this的值，即setTimeout回调中的this即是obj，this.a访问obj的a属性，所以输出20，如果箭头函数换成原来的匿名函数，此时的this指向由上下文来决定，此时this会指向window，会输出10

## 六、简述Symbol类型的用途？
答：
- 用于创建一个独一无二的值，用作唯一key用于缓存场景
- 用于类的私有属性，利用symbol属性是不能被枚举的
- 用来重新对象的属性，比如使用Symbol.iterator可以将一个对象变为可迭代的对象

## 七、说说什么是浅拷贝、什么是深拷贝？

- 浅拷贝：仅拷贝原来的对象的指针，没有产生新的对象以及内存空间，源对象和副本对象是同一个对象。
- 深拷贝：不仅产生了新的指针，还生成了一个新对象，修改新对象，不会影响到原来的对象

## 八、请简述ts和js之间的关系？

ts 是 js的一个超集，ts包括了js的所有内容，还在原来的基础上增加了静态类型、类、接口和类型注释方面的功能。

## 九、简述ts的优缺点？

优点：
- 增强了代码的可维护性以及可读性
- 降低了代码在执行时出错的风险、大部分的风险在编译时候就能够直接爆出
- 包容性非常好，js更改后缀名即可

缺点：
- 存在一定的学习成本，需要理解接口、范型、枚举等一些概念
- 短期来说，会增加一定的开发成本
- 集成和构建需要一定工作量

## 十、描述引用技术的工作原理、以及优缺点？
工作原理：首先对内存设置引用计数器，当引用关系放生变化是，修改引用计数器的值，当引用计数器的值为0时，回收内存

优点：
- 发现垃圾时，能够立即回收
- 最大限度减少了程序暂停

缺点：
- 如果出现循环引用，将不能够被进行垃圾回收
- 时间开销大

## 十一、描述标记整理算法的工作流程
首先对所有的活动对象进行标记，遍历所有对象，对所有的活动对象内存空间进行整理，移动对象位置，使内存空间连续，释放掉所有未标记的对象。

## 十二、描述V8中新生代垃圾回收的流程

新生代内存空间两个等大的空间，使用空间为from，空闲空间为 to，活动对象均存在from空间。在最初触发时，将from空间进行标记整理后，将活动对象拷贝至to空间，from与to空间进行交换，释放空间。

如果新生代空间经过一轮垃圾回收，还存在，该部分会晋升到老生代存储区
如果TO空间超过使用率超过25%，也会移动到老生代存储区。

## 十三、描述增量标记算法的何时使用以及工作原理

当标记清除的空间碎片不足新生代空间晋升的时候，会采用标记清理对空间碎片进行整理，同时使用增量标记进行速度优化，即程序执行一段时间后，进行部分的活动对象的标记，标记一部分后，继续执行js程序，如此往复，直到所有新增的活动对象都被标记完，开始进行回收